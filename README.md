# Домашнее задание к занятию «Резервное копирование баз данных»
## Косарев Д.О.

---

## **Задание 1. Резервное копирование**

### 1.1. Восстановление данных в полном объёме за предыдущий день
Для этого подходит **ежедневное полное резервное копирование (Full Backup)**, выполняемое один раз в сутки (например, ночью, когда нагрузка минимальна).  
**Почему это подходит:**
- Резервная копия содержит все данные на момент окончания предыдущего дня.
- Восстановление происходит быстро из одного архива.
- Минус: большой объём хранимых данных и высокая нагрузка на систему во время создания бэкапа.

**Альтернатива:** Еженедельное полное копирование + ежедневные инкрементные/дифференциальные бэкапы, но восстановление за предыдущий день потребует применения цепочки бэкапов.

---

### 1.2. Восстановление данных за час до поломки
Здесь нужен **комбинированный подход**:
1. **Полное резервное копирование** (раз в сутки или реже).
2. **Инкрементное или дифференциальное копирование** каждые несколько часов.
3. **Резервирование журналов транзакций (WAL в PostgreSQL, binlog в MySQL)** для восстановления на момент времени (Point-in-Time Recovery, PITR).

**Почему это подходит:**
- Инкрементные/дифференциальные бэкапы уменьшают нагрузку и место на диске.
- Журналы транзакций позволяют восстановить данные на точный момент (до часа до сбоя).
- Пример: полный бэкап в 00:00 + инкрементные каждые 4 часа + непрерывная архивация WAL/binlog.

---

## **Задание 2. PostgreSQL**

### 2.1. Пример резервирования и восстановления через `pg_dump`/`pg_restore`

**Резервирование (дамп) с помощью `pg_dump`:**
\`\`\`bash
# Дамп в формате кастомном (подходит для pg_restore)
pg_dump -U username -d database_name -F c -f /backup/backup.dump

# Опции:
# -U — пользователь
# -d — база данных
# -F c — формат custom (сжатый, поддерживает выбор объектов при восстановлении)
# -f — файл для вывода
\`\`\`

**Восстановление с помощью `pg_restore`:**
\`\`\`bash
# Восстановить всю БД
pg_restore -U username -d new_database_name /backup/backup.dump

# Восстановить только структуру (без данных)
pg_restore -U username -d new_database_name --schema-only /backup/backup.dump

# Восстановить только данные
pg_restore -U username -d new_database_name --data-only /backup/backup.dump
\`\`\`

**Для Point-in-Time Recovery** используется непрерывная архивация WAL-файлов и восстановление до метки времени (с помощью `pg_basebackup` и `recovery.conf`/`postgresql.conf`).

---

## **Задание 3. MySQL**

### 3.1. Пример инкрементного резервного копирования

**Инкрементное копирование в MySQL обычно основывается на binlog.**

1. **Полный бэкап (раз в сутки) через `mysqldump` или `mysqlbackup` (для InnoDB):**
\`\`\`bash
mysqldump -u root -p --single-transaction --flush-logs --master-data=2 --all-databases > full_backup.sql
\`\`\`
   - `--flush-logs` — закрывает текущий binlog и начинает новый (важно для инкрементных бэкапов).
   - `--master-data=2` — записывает позицию binlog в дамп.

2. **Инкрементный бэкап — копирование binlog-файлов, созданных после полного бэкапа:**
\`\`\`bash
# После полного бэкапа копируем новые binlog-файлы
cp /var/lib/mysql/mysql-bin.0000* /backup/incremental/
\`\`\`

3. **Восстановление:**
   - Восстановить полный бэкап.
   - Применить инкрементные binlog-файлы с помощью `mysqlbinlog`:
\`\`\`bash
mysqlbinlog /backup/incremental/mysql-bin.00000X | mysql -u root -p
\`\`\`

**Использование утилиты `mariabackup`/`xtrabackup` (поддерживает инкрементные бэкапы на уровне файлов):**
\`\`\`bash
# Полный бэкап
mariabackup --backup --target-dir=/backup/full --user=root --password=123

# Инкрементный бэкап (относительно полного)
mariabackup --backup --target-dir=/backup/inc1 --incremental-basedir=/backup/full --user=root --password=123
\`\`\`

Для MySQL Enterprise Edition доступен `mysqlbackup` с встроенной поддержкой инкрементных бэкапов.
